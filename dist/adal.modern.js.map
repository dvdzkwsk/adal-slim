{"version":3,"file":"adal.modern.js","sources":["../lib/adal.ts"],"sourcesContent":["//----------------------------------------------------------------------\n// @preserve Copyright (c) Microsoft Open Technologies, Inc.\n// All Rights Reserved\n// Apache License 2.0\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//----------------------------------------------------------------------\ndeclare const DEBUG: boolean\n\nenum RequestType {\n    LOGIN = \"LOGIN\",\n    RENEW_TOKEN = \"RENEW_TOKEN\",\n    UNKNOWN = \"UNKNOWN\",\n}\nenum ResponseType {\n    ID_TOKEN = \"id_token token\",\n    TOKEN = \"token\",\n}\n\nenum TokenRenewStatus {\n    Canceled = \"Canceled\",\n    Completed = \"Completed\",\n    InProgress = \"In Progress\",\n}\n\nconst ACCESS_TOKEN = \"access_token\",\n    EXPIRES_IN = \"expires_in\",\n    ID_TOKEN = \"id_token\",\n    ERROR = \"error\",\n    ERROR_DESCRIPTION = \"error_description\",\n    SESSION_STATE = \"session_state\",\n    RESOURCE_DELIMETER = \"|\",\n    CACHE_DELIMETER = \"||\",\n    SINGLETON = \"_adalInstance\"\n\ntype RequestInfo = {\n    parameters: {[key: string]: any}\n    requestType: RequestType\n    stateMatch: boolean\n    stateResponse: string\n    valid: boolean\n}\n\nexport type Config = any // TODO\nexport type User =\n    | {\n          profile: UserProfile\n      }\n    | undefined\n\ninterface UserProfile {\n    aud: string\n    iss: string\n    iat: number\n    nbf: number\n    exp: number\n    acct: number\n    aio: string\n    amr: string[]\n    family_name: string\n    given_name: string\n    in_corp: string\n    ipaddr: string\n    name: string\n    nonce: string\n    oid: string\n    onprem_sid: string\n    puid: string\n    rh: string\n    sub: string\n    tid: string\n    unique_name: string\n    upn: string\n    uti: string\n    ver: string\n    xms_mpci: number\n    xms_pci: number\n    mri: string\n}\n\nexport interface AuthenticationContext {\n    config: Config\n    login(): void\n    logout(): void\n    loginInProgress(): boolean\n    getUser(): User | undefined\n    registerCallback(expectedState: any, resource: string, callback: any): void\n    acquireToken(resource: string, callback: any): void\n    acquireTokenPopup(\n        resource: string,\n        extraQueryParameters: string,\n        claims: string | undefined,\n        callback: any,\n    ): void\n    getRequestInfo(hash: string): RequestInfo\n    saveTokenFromHash(requestInfo: RequestInfo): void\n    handleWindowCallback(hash?: string): void\n    _callBackMappedToRenewStates: any\n    _callBacksMappedToRenewStates: any\n}\n\nexport let AuthenticationContext: {\n    new (config: Config): AuthenticationContext\n} = ((config: Config): AuthenticationContext => {\n    if (window[SINGLETON]) {\n        return window[SINGLETON]\n    }\n\n    config = readConfig(config)\n    let _user: any\n    let _idTokenNonce: any\n    let _activeRenewals: any = {}\n    let _loginInProgress = false\n    let _acquireTokenInProgress = false\n    let _renewStates: any[] = []\n    let _openedWindows: any[] = []\n    let _callBackMappedToRenewStates: any = {}\n    let _callBacksMappedToRenewStates: any = {}\n    let _requestType = RequestType.LOGIN\n\n    /**\n     * Initiates the login process by redirecting the user to Azure AD authorization endpoint.\n     */\n    function login() {\n        if (_loginInProgress) {\n            if (DEBUG) {\n                Logger.info(\"Login in progress\")\n            }\n            return\n        }\n\n        _loginInProgress = true\n\n        // Token is not present and user needs to login\n        const expectedState = guid()\n        const loginStartPage = window.location.href\n        config.state = expectedState\n        _idTokenNonce = guid()\n\n        if (DEBUG) {\n            Logger.verbose(\n                \"Expected state: \" +\n                    expectedState +\n                    \" startPage:\" +\n                    loginStartPage,\n            )\n        }\n        saveItem(StorageKey.LOGIN_REQUEST, loginStartPage)\n        saveItem(StorageKey.LOGIN_ERROR, \"\")\n        saveItem(StorageKey.STATE_LOGIN, expectedState, true)\n        saveItem(StorageKey.NONCE_IDTOKEN, _idTokenNonce, true)\n        saveItem(StorageKey.ERROR, \"\")\n        saveItem(StorageKey.ERROR_DESCRIPTION, \"\")\n        const url =\n            getNavigateUrl(\"id_token\") + \"&nonce=\" + encode(_idTokenNonce)\n\n        if (config.displayCall) {\n            config.displayCall(url)\n        } else if (config.popUp) {\n            saveItem(StorageKey.STATE_LOGIN, \"\") // so requestInfo does not match redirect case\n            _renewStates.push(expectedState)\n            registerCallback(expectedState, config.clientId, config.callback)\n            loginPopup(url)\n        } else {\n            promptUser(url)\n        }\n    }\n\n    /**\n     * Configures popup window for login.\n     * @ignore\n     */\n    function openPopup(\n        urlNavigate: string,\n        title: string,\n        popUpWidth: number,\n        popUpHeight: number,\n    ) {\n        try {\n            const left = window.innerWidth / 2 - popUpWidth / 2 + window.screenX\n            const top =\n                window.innerHeight / 2 - popUpHeight / 2 + window.screenY\n            const popupWindow = window.open(\n                urlNavigate,\n                title,\n                \"width=\" +\n                    popUpWidth +\n                    \", height=\" +\n                    popUpHeight +\n                    \", top=\" +\n                    top +\n                    \", left=\" +\n                    left,\n            )!\n            if (popupWindow.focus) {\n                popupWindow.focus()\n            }\n            return popupWindow\n        } catch (e) {\n            if (DEBUG) {\n                Logger.warn(\"Error opening popup, \" + e.message)\n            }\n            _loginInProgress = false\n            _acquireTokenInProgress = false\n        }\n    }\n\n    function handlePopupError(\n        loginCallback: any,\n        resource: string | undefined | null,\n        error: string,\n        errorDesc: string,\n        loginError: string,\n    ) {\n        if (DEBUG) {\n            Logger.warn(errorDesc)\n        }\n        saveItem(StorageKey.ERROR, error)\n        saveItem(StorageKey.ERROR_DESCRIPTION, errorDesc)\n        saveItem(StorageKey.LOGIN_ERROR, loginError)\n\n        if (resource && _activeRenewals[resource]) {\n            _activeRenewals[resource] = null\n        }\n\n        _loginInProgress = false\n        _acquireTokenInProgress = false\n\n        if (loginCallback) {\n            loginCallback(errorDesc, null, error)\n        }\n    }\n\n    /**\n     * After authorization, the user will be sent to your specified redirect_uri with the user's bearer token\n     * attached to the URI fragment as an id_token field. It closes popup window after redirection.\n     * @ignore\n     */\n    function loginPopup(\n        urlNavigate: string,\n        resource?: string,\n        callback?: any,\n    ) {\n        var popupWindow = openPopup(urlNavigate, \"login\", 483, 600)\n        var loginCallback = callback || config.callback\n\n        if (!popupWindow) {\n            var error = \"Error opening popup\"\n            var errorDesc =\n                \"Popup Window is null. This can happen if you are using IE\"\n            handlePopupError(\n                loginCallback,\n                resource,\n                error,\n                errorDesc,\n                errorDesc,\n            )\n            return\n        }\n\n        _openedWindows.push(popupWindow)\n        const registeredRedirectUri = config.redirectUri.split(\"#\")[0]\n\n        let pollTimer = setInterval(() => {\n            if (\n                !popupWindow ||\n                popupWindow.closed ||\n                popupWindow.closed === undefined\n            ) {\n                let error = \"Popup Window closed\"\n                let errorDesc =\n                    \"Popup Window closed by UI action/ Popup Window handle destroyed due to cross zone navigation in IE/Edge\"\n\n                handlePopupError(\n                    loginCallback,\n                    resource,\n                    error,\n                    errorDesc,\n                    errorDesc,\n                )\n                clearInterval(pollTimer)\n                return\n            }\n\n            try {\n                let popUpWindowLocation = popupWindow.location\n                if (\n                    encodeURI(popUpWindowLocation.href).indexOf(\n                        encodeURI(registeredRedirectUri),\n                    ) != -1\n                ) {\n                    handleWindowCallback(popUpWindowLocation.hash)\n                    clearInterval(pollTimer)\n                    _loginInProgress = false\n                    _acquireTokenInProgress = false\n                    if (DEBUG) {\n                        Logger.info(\"Closing popup window\")\n                    }\n                    _openedWindows = []\n                    popupWindow.close()\n                    return\n                }\n            } catch (e) {}\n        }, 1)\n    }\n\n    function getUser() {\n        if (!_user) {\n            const idToken = getItem(StorageKey.IDTOKEN)\n            if (idToken) {\n                _user = createUser(idToken)\n            }\n        }\n        return _user\n    }\n\n    /**\n     * Gets token for the specified resource from the cache.\n     * @param {string}   resource A URI that identifies the resource for which the token is requested.\n     * @returns {string} token if if it exists and not expired, otherwise null.\n     */\n    function getCachedToken(resource: string): string | undefined {\n        if (!hasResource(resource)) return\n\n        const token = getItem(StorageKey.ACCESS_TOKEN_KEY + resource)\n        const expiry = getItem(StorageKey.EXPIRATION_KEY + resource)\n\n        if (expiry && expiry > now() + config.expireOffsetSeconds) {\n            return token\n        } else {\n            saveItem(StorageKey.ACCESS_TOKEN_KEY + resource, \"\")\n            saveItem(StorageKey.EXPIRATION_KEY + resource, 0)\n        }\n    }\n\n    /**\n     * Adds the passed callback to the array of callbacks for the specified resource and puts the array on the window object.\n     * @param {string}   resource A URI that identifies the resource for which the token is requested.\n     * @param {string}   expectedState A unique identifier (guid).\n     * @param {tokenCallback} callback - The callback provided by the caller. It will be called with token or error.\n     */\n    function registerCallback(\n        expectedState: any,\n        resource: string,\n        callback: any,\n    ) {\n        _activeRenewals[resource] = expectedState\n\n        if (!_callBacksMappedToRenewStates[expectedState]) {\n            _callBacksMappedToRenewStates[expectedState] = []\n        }\n\n        _callBacksMappedToRenewStates[expectedState].push(callback)\n\n        if (!_callBackMappedToRenewStates[expectedState]) {\n            _callBackMappedToRenewStates[expectedState] = (\n                errorDesc,\n                token,\n                error,\n                tokenType,\n            ) => {\n                _activeRenewals[resource] = null\n\n                for (\n                    var i = 0;\n                    i < _callBacksMappedToRenewStates[expectedState].length;\n                    ++i\n                ) {\n                    try {\n                        _callBacksMappedToRenewStates[expectedState][i](\n                            errorDesc,\n                            token,\n                            error,\n                            tokenType,\n                        )\n                    } catch (error) {\n                        if (DEBUG) {\n                            Logger.warn(error)\n                        }\n                    }\n                }\n\n                _callBacksMappedToRenewStates[expectedState] = null\n                _callBackMappedToRenewStates[expectedState] = null\n            }\n        }\n    }\n\n    /**\n     * Acquires access token with hidden iframe\n     * @ignore\n     */\n    function renewToken(resource, callback, responseType = \"token\") {\n        // use iframe to try to renew token\n        // use given resource to create new authz url\n        if (DEBUG) {\n            Logger.info(\"renewToken is called for resource:\" + resource)\n        }\n        let frameHandle = addAdalFrame(\"adalRenewFrame\" + resource)\n        let expectedState = guid() + RESOURCE_DELIMETER + resource\n        config.state = expectedState\n        _renewStates.push(expectedState)\n        if (DEBUG) {\n            Logger.verbose(\"Renew token Expected state: \" + expectedState)\n        }\n        // remove the existing prompt=... query parameter and add prompt=none\n        let urlNavigate = removeQueryStringParameter(\n            getNavigateUrl(responseType, resource),\n            \"prompt\",\n        )\n\n        if (responseType === ResponseType.ID_TOKEN) {\n            _idTokenNonce = guid()\n            saveItem(StorageKey.NONCE_IDTOKEN, _idTokenNonce, true)\n            urlNavigate += \"&nonce=\" + encode(_idTokenNonce)\n        }\n\n        urlNavigate += \"&prompt=none\"\n        urlNavigate = addHintParameters(urlNavigate)\n        registerCallback(expectedState, resource, callback)\n        if (DEBUG) {\n            Logger.verbosePii(\"Navigate to:\" + urlNavigate)\n        }\n        frameHandle.src = \"about:blank\"\n        loadFrameTimeout(urlNavigate, \"adalRenewFrame\" + resource, resource)\n    }\n\n    /**\n     * Renews idtoken for app's own backend when resource is clientId and calls the callback with token/error\n     * @ignore\n     */\n    function renewIdToken(callback, responseType?: string) {\n        // use iframe to try to renew token\n        let frameHandle = addAdalFrame(\"adalIdTokenFrame\")\n        let expectedState = guid() + RESOURCE_DELIMETER + config.clientId\n        _idTokenNonce = guid()\n        saveItem(StorageKey.NONCE_IDTOKEN, _idTokenNonce, true)\n        config.state = expectedState\n        // renew happens in iframe, so it keeps javascript context\n        _renewStates.push(expectedState)\n        if (DEBUG) {\n            Logger.verbose(\"Renew Idtoken Expected state: \" + expectedState)\n        }\n        // remove the existing prompt=... query parameter and add prompt=none\n        let resource = responseType || config.clientId\n        responseType = responseType || \"id_token\"\n        let urlNavigate = removeQueryStringParameter(\n            getNavigateUrl(responseType, resource),\n            \"prompt\",\n        )\n        urlNavigate = addHintParameters(urlNavigate + \"&prompt=none\")\n        urlNavigate += \"&nonce=\" + encode(_idTokenNonce)\n        registerCallback(expectedState, config.clientId, callback)\n        if (DEBUG) {\n            Logger.verbosePii(\"Navigate to:\" + urlNavigate)\n        }\n        frameHandle.src = \"about:blank\"\n        loadFrameTimeout(urlNavigate, \"adalIdTokenFrame\", config.clientId)\n    }\n\n    function loadFrameTimeout(urlNavigation, frameName, resource) {\n        //set iframe session to pending\n        if (DEBUG) {\n            Logger.verbose(\"Set loading state to pending for: \" + resource)\n        }\n        saveItem(\n            StorageKey.RENEW_STATUS + resource,\n            TokenRenewStatus.InProgress,\n        )\n        loadFrame(urlNavigation, frameName)\n\n        setTimeout(() => {\n            if (\n                getItem(StorageKey.RENEW_STATUS + resource) ===\n                TokenRenewStatus.InProgress\n            ) {\n                // fail the iframe session if it's in pending state\n                if (DEBUG) {\n                    Logger.verbose(\n                        \"Loading frame has timed out after: \" +\n                            config.loadFrameTimeout / 1000 +\n                            \" seconds for resource \" +\n                            resource,\n                    )\n                }\n                var expectedState = _activeRenewals[resource]\n\n                if (\n                    expectedState &&\n                    _callBackMappedToRenewStates[expectedState]\n                ) {\n                    _callBackMappedToRenewStates[expectedState](\n                        \"Token renewal operation failed due to timeout\",\n                        null,\n                        \"Token Renewal Failed\",\n                    )\n                }\n\n                saveItem(\n                    StorageKey.RENEW_STATUS + resource,\n                    TokenRenewStatus.Canceled,\n                )\n            }\n        }, config.loadFrameTimeout)\n    }\n\n    /**\n     * Loads iframe with authorization endpoint URL\n     */\n    function loadFrame(urlNavigate, frameName) {\n        // This trick overcomes iframe navigation in IE\n        // IE does not load the page consistently in iframe\n        if (DEBUG) {\n            Logger.info(\"LoadFrame: \" + frameName)\n        }\n        setTimeout(() => {\n            const frameHandle = addAdalFrame(frameName) as any\n            if (!frameHandle.src || frameHandle.src === \"about:blank\") {\n                frameHandle.src = urlNavigate\n                loadFrame(urlNavigate, frameName)\n            }\n        }, 500)\n    }\n\n    /**\n     * Acquires token from the cache if it is not expired. Otherwise sends request to AAD to obtain a new token.\n     * @param {string}   resource  ResourceUri identifying the target resource\n     */\n    function acquireToken(resource, callback) {\n        if (!resource) {\n            const error = \"resource is required\"\n            if (DEBUG) {\n                Logger.warn(error)\n            }\n            callback(error, null, error)\n            return\n        }\n\n        const token = getCachedToken(resource)\n        if (token) {\n            if (DEBUG) {\n                Logger.info(\n                    \"Token is already in cache for resource:\" + resource,\n                )\n            }\n            callback(null, token, null)\n            return\n        }\n\n        if (\n            !_user &&\n            !(\n                config.extraQueryParameter &&\n                config.extraQueryParameter.indexOf(\"login_hint\") !== -1\n            )\n        ) {\n            const error = \"User login is required\"\n            if (DEBUG) {\n                Logger.warn(error)\n            }\n            callback(error, null, error)\n            return\n        }\n\n        // renew attempt with iframe\n        // Already renewing for this resource, callback when we get the token.\n        if (_activeRenewals[resource]) {\n            // Active renewals contains the state for each renewal.\n            registerCallback(_activeRenewals[resource], resource, callback)\n        } else {\n            _requestType = RequestType.RENEW_TOKEN\n            if (resource === config.clientId) {\n                // App uses idtoken to send to api endpoints\n                // Default resource is tracked as clientid to store this token\n                if (_user) {\n                    if (DEBUG) {\n                        Logger.verbose(\"renewing idtoken\")\n                    }\n                    renewIdToken(callback)\n                } else {\n                    if (DEBUG) {\n                        Logger.verbose(\"renewing idtoken and access_token\")\n                    }\n                    renewIdToken(callback, ResponseType.ID_TOKEN)\n                }\n            } else {\n                if (_user) {\n                    if (DEBUG) {\n                        Logger.verbose(\"renewing access_token\")\n                    }\n                    renewToken(resource, callback)\n                } else {\n                    if (DEBUG) {\n                        Logger.verbose(\"renewing idtoken and access_token\")\n                    }\n                    renewToken(resource, callback, ResponseType.ID_TOKEN)\n                }\n            }\n        }\n    }\n\n    /**\n     * Acquires token (interactive flow using a popUp window) by sending request to AAD to obtain a new token.\n     * @param {string}   resource  ResourceUri identifying the target resource\n     * @param {string}   extraQueryParameters  extraQueryParameters to add to the authentication request\n     * @param {tokenCallback} callback -  The callback provided by the caller. It will be called with token or error.\n     */\n    function acquireTokenPopup(\n        resource,\n        extraQueryParameters,\n        claims,\n        callback,\n    ) {\n        if (!canAcquireToken(resource)) {\n            return\n        }\n\n        var expectedState = guid() + RESOURCE_DELIMETER + resource\n        config.state = expectedState\n        _renewStates.push(expectedState)\n        _requestType = RequestType.RENEW_TOKEN\n        if (DEBUG) {\n            Logger.verbose(\"Renew token Expected state: \" + expectedState)\n        }\n        // remove the existing prompt=... query parameter and add prompt=select_account\n        var urlNavigate = removeQueryStringParameter(\n            getNavigateUrl(\"token\", resource),\n            \"prompt\",\n        )\n        urlNavigate += \"&prompt=select_account\"\n\n        if (extraQueryParameters) {\n            urlNavigate += extraQueryParameters\n        }\n        if (claims) {\n            if (urlNavigate.indexOf(\"&claims\") === -1) {\n                urlNavigate += \"&claims=\" + encode(claims)\n            } else {\n                throw new Error(\n                    \"Claims cannot be passed as an extraQueryParameter\",\n                )\n            }\n        }\n\n        urlNavigate = addHintParameters(urlNavigate)\n        _acquireTokenInProgress = true\n        if (DEBUG) {\n            Logger.info(\n                \"acquireToken interactive is called for the resource \" +\n                    resource,\n            )\n        }\n        registerCallback(expectedState, resource, callback)\n        loginPopup(urlNavigate, resource, callback)\n    }\n\n    /**\n     * Acquires token (interactive flow using a redirect) by sending request to AAD to obtain a new token. In this case the callback passed in the Authentication\n     * request constructor will be called.\n     * @param {string}   resource  ResourceUri identifying the target resource\n     * @param {string}   extraQueryParameters  extraQueryParameters to add to the authentication request\n     */\n    function acquireTokenRedirect(resource, extraQueryParameters, claims) {\n        if (!canAcquireToken(resource)) {\n            return\n        }\n\n        const expectedState = guid() + RESOURCE_DELIMETER + resource\n        config.state = expectedState\n        if (DEBUG) {\n            Logger.verbose(\"Renew token Expected state: \" + expectedState)\n        }\n\n        // remove the existing prompt=... query parameter and add prompt=select_account\n        var urlNavigate = removeQueryStringParameter(\n            getNavigateUrl(\"token\", resource),\n            \"prompt\",\n        )\n        urlNavigate = urlNavigate + \"&prompt=select_account\"\n        if (extraQueryParameters) {\n            urlNavigate += extraQueryParameters\n        }\n\n        if (claims && urlNavigate.indexOf(\"&claims\") === -1) {\n            urlNavigate += \"&claims=\" + encode(claims)\n        } else if (claims && urlNavigate.indexOf(\"&claims\") !== -1) {\n            throw new Error(\"Claims cannot be passed as an extraQueryParameter\")\n        }\n\n        urlNavigate = addHintParameters(urlNavigate)\n        _acquireTokenInProgress = true\n        if (DEBUG) {\n            Logger.info(\n                \"acquireToken interactive is called for the resource \" +\n                    resource,\n            )\n        }\n        saveItem(StorageKey.LOGIN_REQUEST, window.location.href)\n        saveItem(StorageKey.STATE_RENEW, expectedState, true)\n        promptUser(urlNavigate)\n    }\n\n    function canAcquireToken(resource: string): boolean {\n        let error: string | undefined\n        if (!resource) {\n            error = \"Resource is required\"\n        } else if (!_user) {\n            error = \"User login is required\"\n        } else if (_acquireTokenInProgress) {\n            error = \"Acquire token interactive is already in progress\"\n        }\n        if (error) {\n            if (DEBUG) {\n                Logger.warn(error)\n            }\n            config.callback(error, null, error)\n        }\n        return !error\n    }\n\n    /**\n     * Redirects the browser to Azure AD authorization endpoint.\n     */\n    function promptUser(url: string) {\n        if (url) {\n            if (DEBUG) {\n                Logger.infoPii(\"Navigate to:\" + url)\n            }\n            window.location.replace(url)\n        } else {\n            if (DEBUG) {\n                Logger.info(\"Navigate url is empty\")\n            }\n        }\n    }\n\n    function clearCache() {\n        saveItem(StorageKey.LOGIN_REQUEST, \"\")\n        saveItem(StorageKey.SESSION_STATE, \"\")\n        saveItem(StorageKey.STATE_LOGIN, \"\")\n        saveItem(StorageKey.STATE_RENEW, \"\")\n        _renewStates = []\n        saveItem(StorageKey.NONCE_IDTOKEN, \"\")\n        saveItem(StorageKey.IDTOKEN, \"\")\n        saveItem(StorageKey.ERROR, \"\")\n        saveItem(StorageKey.ERROR_DESCRIPTION, \"\")\n        saveItem(StorageKey.LOGIN_ERROR, \"\")\n        saveItem(StorageKey.LOGIN_ERROR, \"\")\n        var keys = getItem(StorageKey.TOKEN_KEYS) as any\n\n        if (!isEmpty(keys)) {\n            keys = keys.split(RESOURCE_DELIMETER)\n            for (var i = 0; i < keys.length && keys[i] !== \"\"; i++) {\n                saveItem(StorageKey.ACCESS_TOKEN_KEY + keys[i], \"\")\n                saveItem(StorageKey.EXPIRATION_KEY + keys[i], 0)\n            }\n        }\n\n        saveItem(StorageKey.TOKEN_KEYS, \"\")\n    }\n\n    /**\n     * Redirects user to logout endpoint.\n     * After logout, it will redirect to postLogoutRedirectUri if added as a property on the config object.\n     */\n    function logout() {\n        clearCache()\n        _user = null\n        let urlNavigate: string\n\n        if (config.logOutUri) {\n            urlNavigate = config.logOutUri\n        } else {\n            let logout = \"\"\n            if (config.postLogoutRedirectUri) {\n                logout =\n                    \"post_logout_redirect_uri=\" +\n                    encode(config.postLogoutRedirectUri)\n            }\n\n            urlNavigate =\n                config.instance + config.tenant + \"/oauth2/logout?\" + logout\n        }\n\n        if (DEBUG) {\n            Logger.infoPii(\"Logout navigate to: \" + urlNavigate)\n        }\n        promptUser(urlNavigate)\n    }\n\n    /**\n     * Adds login_hint to authorization URL which is used to pre-fill the username field of sign in page for the user if known ahead of time.\n     * domain_hint can be one of users/organisations which when added skips the email based discovery process of the user.\n     * @ignore\n     */\n    function addHintParameters(url: string) {\n        //If you dont use prompt=none, then if the session does not exist, there will be a failure.\n        //If sid is sent alongside domain or login hints, there will be a failure since request is ambiguous.\n        //If sid is sent with a prompt value other than none or attempt_none, there will be a failure since the request is ambiguous.\n\n        if (!_user || !_user.profile) {\n            return url\n        }\n\n        if (_user.profile.sid && url.indexOf(\"&prompt=none\") !== -1) {\n            // don't add sid twice if user provided it in the extraQueryParameter value\n            if (!urlContainsQueryStringParameter(\"sid\", url)) {\n                // add sid\n                url += \"&sid=\" + encode(_user.profile.sid)\n            }\n        } else if (_user.profile.upn) {\n            // don't add login_hint twice if user provided it in the extraQueryParameter value\n            if (!urlContainsQueryStringParameter(\"login_hint\", url)) {\n                // add login_hint\n                url += \"&login_hint=\" + encode(_user.profile.upn)\n            }\n            // don't add domain_hint twice if user provided it in the extraQueryParameter value\n            if (\n                !urlContainsQueryStringParameter(\"domain_hint\", url) &&\n                _user.profile.upn.indexOf(\"@\") > -1\n            ) {\n                var parts = _user.profile.upn.split(\"@\")\n                // local part can include @ in quotes. Sending last part handles that.\n                url += \"&domain_hint=\" + encode(parts[parts.length - 1])\n            }\n        }\n        return url\n    }\n\n    /**\n     * Creates a user object by decoding the id_token\n     * @ignore\n     */\n    function createUser(idToken) {\n        const json = extractIdToken(idToken)\n        if (!has(json, \"aud\")) {\n            return\n        }\n\n        if (json.aud.toLowerCase() !== config.clientId.toLowerCase()) {\n            if (DEBUG) {\n                Logger.warn(\"IdToken has invalid aud field\")\n            }\n        } else {\n            return {\n                userName: json.upn || json.email,\n                profile: json,\n            }\n        }\n    }\n\n    /**\n     * Gets login error\n     * @returns {string} error message related to login.\n     */\n    function getLoginError() {\n        return getItem(StorageKey.LOGIN_ERROR)\n    }\n\n    /**\n     * Creates a requestInfo object from the URL fragment and returns it.\n     */\n    function getRequestInfo(hash): RequestInfo {\n        const requestInfo: RequestInfo = {\n            valid: false,\n            parameters: {},\n            stateMatch: false,\n            stateResponse: \"\",\n            requestType: RequestType.UNKNOWN,\n        }\n\n        const parameters = deserialize(getHash(hash)) as any\n        if (!parameters) {\n            return requestInfo\n        }\n\n        requestInfo.parameters = parameters\n        if (\n            has(parameters, ERROR_DESCRIPTION) ||\n            has(parameters, ACCESS_TOKEN) ||\n            has(parameters, ID_TOKEN)\n        ) {\n            requestInfo.valid = true\n\n            if (has(parameters, \"state\")) {\n                if (DEBUG) {\n                    Logger.verbose(\"State: \" + parameters.state)\n                }\n                requestInfo.stateResponse = parameters.state\n            } else {\n                if (DEBUG) {\n                    Logger.warn(\"No state returned\")\n                }\n                return requestInfo\n            }\n\n            // async calls can fire iframe and login request at the same time if developer does not use the API as expected\n            // incoming callback needs to be looked up to find the request type\n            // loginRedirect or acquireTokenRedirect\n            if (matchState(requestInfo)) {\n                return requestInfo\n            }\n\n            // external api requests may have many renewtoken requests for different resource\n            if (!requestInfo.stateMatch && window.parent) {\n                requestInfo.requestType = _requestType\n                for (const state of _renewStates) {\n                    if (state === requestInfo.stateResponse) {\n                        requestInfo.stateMatch = true\n                        break\n                    }\n                }\n            }\n        }\n        return requestInfo\n    }\n\n    /**\n     * Matches state from the request with the response.\n     * @ignore\n     */\n    function matchState(requestInfo) {\n        const loginStates = getItem(StorageKey.STATE_LOGIN)\n        if (loginStates) {\n            for (const state of loginStates.split(CACHE_DELIMETER)) {\n                if (state === requestInfo.stateResponse) {\n                    requestInfo.requestType = RequestType.LOGIN\n                    requestInfo.stateMatch = true\n                    return true\n                }\n            }\n        }\n\n        const acquireTokenStates = getItem(StorageKey.STATE_RENEW)\n        if (acquireTokenStates) {\n            for (const state of acquireTokenStates.split(CACHE_DELIMETER)) {\n                if (state === requestInfo.stateResponse) {\n                    requestInfo.requestType = RequestType.RENEW_TOKEN\n                    requestInfo.stateMatch = true\n                    return true\n                }\n            }\n        }\n\n        return false\n    }\n\n    /**\n     * Saves token or error received in the response from AAD in the cache. In case of id_token, it also creates the user object.\n     */\n    function saveTokenFromHash(requestInfo: RequestInfo) {\n        if (DEBUG) {\n            Logger.info(\n                \"State status:\" +\n                    requestInfo.stateMatch +\n                    \"; Request type:\" +\n                    requestInfo.requestType,\n            )\n        }\n        saveItem(StorageKey.ERROR, \"\")\n        saveItem(StorageKey.ERROR_DESCRIPTION, \"\")\n\n        let resource = getResourceFromState(requestInfo.stateResponse)\n\n        // Record error\n        if (has(requestInfo.parameters, ERROR_DESCRIPTION)) {\n            if (DEBUG) {\n                Logger.infoPii(\n                    \"Error :\" +\n                        requestInfo.parameters.error +\n                        \"; Error description:\" +\n                        requestInfo.parameters[ERROR_DESCRIPTION],\n                )\n            }\n            saveItem(StorageKey.ERROR, requestInfo.parameters.error)\n            saveItem(\n                StorageKey.ERROR_DESCRIPTION,\n                requestInfo.parameters[ERROR_DESCRIPTION],\n            )\n\n            if (requestInfo.requestType === RequestType.LOGIN) {\n                _loginInProgress = false\n                saveItem(\n                    StorageKey.LOGIN_ERROR,\n                    requestInfo.parameters.error_description,\n                )\n            }\n        } else {\n            // It must verify the state from redirect\n            if (requestInfo.stateMatch) {\n                // record tokens to storage if exists\n                if (DEBUG) {\n                    Logger.info(\"State is right\")\n                }\n                if (has(requestInfo.parameters, SESSION_STATE)) {\n                    saveItem(\n                        StorageKey.SESSION_STATE,\n                        requestInfo.parameters[SESSION_STATE],\n                    )\n                }\n\n                let keys\n\n                if (has(requestInfo.parameters, ACCESS_TOKEN)) {\n                    if (DEBUG) {\n                        Logger.info(\"Fragment has access token\")\n                    }\n\n                    if (!hasResource(resource)) {\n                        keys = getItem(StorageKey.TOKEN_KEYS) || \"\"\n                        saveItem(\n                            StorageKey.TOKEN_KEYS,\n                            keys + resource + RESOURCE_DELIMETER,\n                        )\n                    }\n\n                    // save token with related resource\n                    saveItem(\n                        StorageKey.ACCESS_TOKEN_KEY + resource,\n                        requestInfo.parameters[ACCESS_TOKEN],\n                    )\n                    saveItem(\n                        StorageKey.EXPIRATION_KEY + resource,\n                        expiresIn(requestInfo.parameters[EXPIRES_IN]),\n                    )\n                }\n\n                if (has(requestInfo.parameters, ID_TOKEN)) {\n                    // info(\"Fragment has id token\")\n                    _loginInProgress = false\n                    _user = createUser(requestInfo.parameters[ID_TOKEN])\n                    if (_user && _user.profile) {\n                        if (!matchNonce(_user)) {\n                            saveItem(\n                                StorageKey.LOGIN_ERROR,\n                                \"Nonce received: \" +\n                                    _user.profile.nonce +\n                                    \" is not same as requested: \" +\n                                    getItem(StorageKey.NONCE_IDTOKEN),\n                            )\n                            _user = null\n                        } else {\n                            saveItem(\n                                StorageKey.IDTOKEN,\n                                requestInfo.parameters[ID_TOKEN],\n                            )\n\n                            // Save idtoken as access token for app itself\n                            resource = config.loginResource\n                                ? config.loginResource\n                                : config.clientId\n\n                            if (!hasResource(resource)) {\n                                keys = getItem(StorageKey.TOKEN_KEYS) || \"\"\n                                saveItem(\n                                    StorageKey.TOKEN_KEYS,\n                                    keys + resource + RESOURCE_DELIMETER,\n                                )\n                            }\n\n                            saveItem(\n                                StorageKey.ACCESS_TOKEN_KEY + resource,\n                                requestInfo.parameters[ID_TOKEN],\n                            )\n                            saveItem(\n                                StorageKey.EXPIRATION_KEY + resource,\n                                _user.profile.exp,\n                            )\n                        }\n                    } else {\n                        const error = \"invalid id_token\"\n                        const description =\n                            \"Invalid id_token. id_token: \" +\n                            requestInfo.parameters[ID_TOKEN]\n\n                        requestInfo.parameters.error = error\n                        requestInfo.parameters.error_description = description\n                        requestInfo.parameters[ID_TOKEN]\n                        saveItem(StorageKey.ERROR, error)\n                        saveItem(StorageKey.ERROR_DESCRIPTION, description)\n                    }\n                }\n            } else {\n                const error = \"Invalid_state\"\n                const description =\n                    \"Invalid_state. state: \" + requestInfo.stateResponse\n\n                requestInfo.parameters.error = error\n                requestInfo.parameters.error_description = description\n\n                saveItem(StorageKey.ERROR, error)\n                saveItem(StorageKey.ERROR_DESCRIPTION, description)\n            }\n        }\n\n        saveItem(StorageKey.RENEW_STATUS + resource, TokenRenewStatus.Completed)\n    }\n\n    /**\n     * This method must be called for processing the response received from AAD. It extracts the hash, processes the token or error, saves it in the cache and calls the registered callbacks with the result.\n     * @param {string} [hash=window.location.hash] - Hash fragment of Url.\n     */\n    function handleWindowCallback(hash: string = window.location.hash) {\n        if (!isCallback(hash)) return\n\n        let self!: AuthenticationContext\n        let isPopup\n\n        const lastWindow = _openedWindows[_openedWindows.length - 1]\n        if (\n            lastWindow &&\n            lastWindow.opener &&\n            lastWindow.opener._AuthenticationContextInstance\n        ) {\n            self = lastWindow.opener._adalInstance\n            isPopup = true\n        } else if (window.parent && (window.parent as any)._adalInstance) {\n            self = (window.parent as any)._adalInstance\n        }\n\n        let requestInfo = self.getRequestInfo(hash)\n        let tokenReceivedCallback: any\n\n        if (isPopup || window.parent !== window) {\n            tokenReceivedCallback =\n                self._callBackMappedToRenewStates[requestInfo.stateResponse]\n        } else {\n            tokenReceivedCallback = self.config.callback\n        }\n\n        self.saveTokenFromHash(requestInfo)\n\n        let token: any\n        let tokenType: any\n        if (\n            requestInfo.requestType === RequestType.RENEW_TOKEN &&\n            window.parent\n        ) {\n            if (DEBUG) {\n                if (window.parent !== window) {\n                    Logger.verbose(\n                        \"Window is in iframe, acquiring token silently\",\n                    )\n                } else {\n                    Logger.verbose(\"acquiring token interactive in progress\")\n                }\n            }\n\n            token =\n                requestInfo.parameters[ACCESS_TOKEN] ||\n                requestInfo.parameters[ID_TOKEN]\n            tokenType = ACCESS_TOKEN\n        } else if (requestInfo.requestType === RequestType.LOGIN) {\n            token = requestInfo.parameters[ID_TOKEN]\n            tokenType = ID_TOKEN\n        }\n\n        try {\n            if (tokenReceivedCallback) {\n                let error = requestInfo.parameters[ERROR]\n                let description = requestInfo.parameters[ERROR_DESCRIPTION]\n                tokenReceivedCallback(description, token, error, tokenType)\n            }\n        } catch (err) {\n            if (DEBUG) {\n                Logger.error(\n                    \"Error occurred in user defined callback function: \" + err,\n                )\n            }\n        }\n\n        if (window.parent === window && !isPopup) {\n            if (self.config.navigateToLoginRequestUrl) {\n                window.location.href = getItem(StorageKey.LOGIN_REQUEST)\n            } else {\n                window.location.hash = \"\"\n            }\n        }\n    }\n\n    /**\n     * Constructs the authorization endpoint URL\n     */\n    let getNavigateUrl = (responseType: string, resource?: string) =>\n        config.instance +\n        config.tenant +\n        \"/oauth2/authorize\" +\n        serialize(responseType, config, resource)\n\n    /**\n     * Returns the decoded id_token.\n     */\n    function extractIdToken(encodedIdToken: string) {\n        // TODO: decodeJWT can be inlined.\n        let decodedToken = decodeJWT(encodedIdToken)\n        if (!decodedToken) {\n            return\n        }\n        try {\n            let base64IdToken = decodedToken.JWSPayload\n            let base64Decoded = base64DecodeStringUrlSafe(base64IdToken)\n\n            if (!base64Decoded) {\n                if (DEBUG) {\n                    Logger.info(\n                        \"The returned id_token could not be base64 url safe decoded.\",\n                    )\n                }\n                return\n            }\n            return JSON.parse(base64Decoded)\n        } catch (err) {\n            if (DEBUG) {\n                Logger.error(\"The returned id_token could not be decoded\", err)\n            }\n        }\n    }\n\n    /**\n     * Decodes a string of data which has been encoded using base-64 encoding.\n     */\n    function base64DecodeStringUrlSafe(base64IdToken: string) {\n        base64IdToken = base64IdToken.replace(/-/g, \"+\").replace(/_/g, \"/\")\n        return decodeURIComponent(escape(window.atob(base64IdToken)))\n    }\n\n    /**\n     * Adds the hidden iframe for silent token renewal\n     */\n    function addAdalFrame(iframeId: string) {\n        let adalFrame = document.getElementById(iframeId)\n        if (adalFrame) {\n            return adalFrame\n        }\n\n        if (DEBUG) {\n            Logger.info(\"Add adal frame to document:\" + iframeId)\n        }\n        // NOTE: removed special case for legacy opera/IE\n        document.body.insertAdjacentHTML(\n            \"beforeEnd\" as any,\n            `<iframe name=\"${iframeId}\" id=\"${iframeId}\" style=\"display:none\"></iframe>`,\n        )\n        return window.frames && window.frames[iframeId]\n    }\n\n    const ctx: AuthenticationContext = (window[SINGLETON] = {\n        config,\n        login,\n        logout,\n        getUser,\n        registerCallback,\n        acquireToken,\n        acquireTokenPopup,\n        getRequestInfo,\n        saveTokenFromHash,\n        loginInProgress: () => _loginInProgress,\n        handleWindowCallback,\n        _callBackMappedToRenewStates,\n        _callBacksMappedToRenewStates,\n    })\n    return ctx\n}) as any\n\nexport let clearCacheForResource = (resource: string) => {\n    saveItem(StorageKey.STATE_RENEW, \"\")\n    saveItem(StorageKey.ERROR, \"\")\n    saveItem(StorageKey.ERROR_DESCRIPTION, \"\")\n\n    if (hasResource(resource)) {\n        saveItem(StorageKey.ACCESS_TOKEN_KEY + resource, \"\")\n        saveItem(StorageKey.EXPIRATION_KEY + resource, 0)\n    }\n}\n\n/**\n * Gets resource for given endpoint if mapping is provided with config.\n */\n// export function getResourceForEndpoint(endpoint: string): string | undefined {\n//     // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.\n//     if (config.anonymousEndpoints) {\n//         for (let i = 0; i < config.anonymousEndpoints.length; i++) {\n//             if (endpoint.indexOf(config.anonymousEndpoints[i]) > -1) {\n//                 return\n//             }\n//         }\n//     }\n\n//     if (config.endpoints) {\n//         for (const configEndpoint in config.endpoints) {\n//             // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n//             if (endpoint.indexOf(configEndpoint) > -1) {\n//                 return config.endpoints[configEndpoint]\n//             }\n//         }\n//     }\n\n//     // default resource will be clientid if nothing specified\n//     // App will use idtoken for calls to itself\n//     // check if it's staring from http or https, needs to match with app host\n//     if (\n//         endpoint.indexOf(\"http://\") > -1 ||\n//         endpoint.indexOf(\"https://\") > -1\n//     ) {\n//         if (haveSameHost(endpoint, config.redirectUri)) {\n//             return config.loginResource\n//         }\n//     } else {\n//         // in angular level, the url for $http interceptor call could be relative url,\n//         // if it's relative call, we'll treat it as app backend call.\n//         return config.loginResource\n//     }\n// }\n\nlet decodeJWT = (\n    jwt: string,\n):\n    | {\n          header: string\n          JWSPayload: string\n          JWSSig: string\n      }\n    | undefined => {\n    if (isEmpty(jwt)) return\n\n    let idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/\n    let matches = idTokenPartsRegex.exec(jwt)\n    if (!matches || matches.length < 4) {\n        if (DEBUG) {\n            Logger.warn(\"The returned id_token is not parseable.\")\n        }\n        return\n    }\n\n    return {\n        header: matches[1],\n        JWSPayload: matches[2],\n        JWSSig: matches[3],\n    }\n}\n\nlet readConfig = (config: Config): Config => {\n    config = {\n        popUp: false,\n        instance: \"https://login.microsoftonline.com/\",\n        loginResource: config.clientId,\n        laodFrameTimeout: 6000,\n        expireOffsetSeconds: 300,\n        navigateToLoginRequestUrl: true,\n        tenant: \"common\",\n        redirectUri: window.location.href.split(\"?\")[0].split(\"#\")[0],\n        callback: () => {},\n        ...config,\n    }\n    if (DEBUG) {\n        Logger.correlationId = config.correlationId\n    }\n    return config\n}\n\n/**\n * Alias for encodeURIComponent for smaller bundle sizes since encodeURIComponent\n * cannot be mangled as it refers to a global.\n */\nlet encode = (str: string) => encodeURIComponent(str)\n\n/**\n * Checks if the authorization endpoint URL contains query string parameters\n */\nlet urlContainsQueryStringParameter = (name: string, url: string) =>\n    new RegExp(\"[\\\\?&]\" + name + \"=\").test(url)\n\n/**\n * Removes the query string parameter from the authorization endpoint URL if it exists\n * we remove &name=value, name=value& and name=value\n */\nlet removeQueryStringParameter = (url: string, name: string) =>\n    url\n        .replace(new RegExp(\"(\\\\&\" + name + \"=)[^&]+\"), \"\")\n        .replace(new RegExp(\"(\" + name + \"=)[^&]+&\"), \"\")\n        .replace(new RegExp(\"(\" + name + \"=)[^&]+\"), \"\")\n\n/**\n * Saves a key-value pair in cache\n */\nlet saveItem = (key: string, value: any, preserve = false) => {\n    if (preserve) {\n        let old = getItem(key) || \"\"\n        Storage.setItem(key, old + value + CACHE_DELIMETER)\n    } else {\n        Storage.setItem(key, value)\n    }\n}\n\n/**\n * Checks for the resource in cache. By default, cache location is Session Storage\n */\nlet hasResource = (key: string): boolean => {\n    let keys = getItem(StorageKey.TOKEN_KEYS)\n    return !isEmpty(keys) && keys.indexOf(key + RESOURCE_DELIMETER) > -1\n}\n\n/**\n * Returns the anchor part (#) of the URL\n * TODO: can just use URL API?\n */\nlet getHash = (hash: string) => {\n    if (hash.indexOf(\"#/\") > -1) {\n        return hash.substring(hash.indexOf(\"#/\") + 2)\n    } else if (hash.indexOf(\"#\") > -1) {\n        return hash.substring(1)\n    } else {\n        return hash\n    }\n}\n\n/**\n * Checks if the URL fragment contains access token, id token or error_description.\n */\nlet isCallback = (hash: string): boolean => {\n    const parameters = deserialize(getHash(hash))\n    return (\n        has(parameters, ERROR_DESCRIPTION) ||\n        has(parameters, ACCESS_TOKEN) ||\n        has(parameters, ID_TOKEN)\n    )\n}\n\n/**\n * Parses the query string parameters into a key-value pair object.\n * @ignore\n */\nlet deserialize = (query: string) => {\n    let pl = /\\+/g, // Regex for replacing addition symbol with a space\n        search = /([^&=]+)=([^&]*)/g,\n        decode = (s: string) => decodeURIComponent(s.replace(pl, \" \")),\n        obj = {}\n\n    let match = search.exec(query)\n    while (match) {\n        obj[decode(match[1])] = decode(match[2])\n        match = search.exec(query)\n    }\n    return obj\n}\n\n/**\n * Matches nonce from the request with the response.\n */\nlet matchNonce = (user: any): boolean => {\n    const requestNonce = getItem(StorageKey.NONCE_IDTOKEN)\n    if (requestNonce) {\n        for (const nonce of requestNonce.split(CACHE_DELIMETER)) {\n            if (nonce === user.profile.nonce) {\n                return true\n            }\n        }\n    }\n    return false\n}\n\nlet getResourceFromState = (state): string => {\n    if (state) {\n        let splitIndex = state.indexOf(RESOURCE_DELIMETER)\n        if (splitIndex > -1 && splitIndex + 1 < state.length) {\n            return state.substring(splitIndex + 1)\n        }\n    }\n    return \"\"\n}\n\n/**\n * Calculates the expires in value in milliseconds for the acquired token\n */\nlet expiresIn = (expires: any) => {\n    // if AAD did not send \"expires_in\" property, use default expiration of 3599 seconds, for some reason AAD sends 3599 as \"expires_in\" value instead of 3600\n    if (!expires) expires = 3599\n    return now() + parseInt(expires, 10)\n}\n\n/**\n * Serializes the parameters for the authorization endpoint URL and returns the serialized uri string.\n */\nlet serialize = (responseType: string, obj: any, resource?: string): string => {\n    if (!obj) return \"\"\n\n    const str: string[] = [\n        \"?response_type=\" + responseType,\n        \"client_id=\" + encode(obj.clientId),\n    ]\n    if (resource) {\n        str.push(\"resource=\" + encode(resource))\n    }\n\n    str.push(\"redirect_uri=\" + encode(obj.redirectUri))\n    str.push(\"state=\" + encode(obj.state))\n\n    if (has(obj, \"slice\")) {\n        str.push(\"slice=\" + encode(obj.slice))\n    }\n\n    if (has(obj, \"extraQueryParameter\")) {\n        str.push(obj.extraQueryParameter)\n    }\n\n    const correlationId = obj.correlationId || guid()\n    str.push(\"client-request-id=\" + encode(correlationId))\n\n    return str.join(\"&\")\n}\n\n/**\n * Generates RFC4122 version 4 guid (128 bits)\n */\nlet guid = () => {\n    // RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or\n    // pseudo-random numbers.\n    // The algorithm is as follows:\n    //     Set the two most significant bits (bits 6 and 7) of the\n    //        clock_seq_hi_and_reserved to zero and one, respectively.\n    //     Set the four most significant bits (bits 12 through 15) of the\n    //        time_hi_and_version field to the 4-bit version number from\n    //        Section 4.1.3. Version4\n    //     Set all the other bits to randomly (or pseudo-randomly) chosen\n    //     values.\n    // UUID                   = time-low \"-\" time-mid \"-\"time-high-and-version \"-\"clock-seq-reserved and low(2hexOctet)\"-\" node\n    // time-low               = 4hexOctet\n    // time-mid               = 2hexOctet\n    // time-high-and-version  = 2hexOctet\n    // clock-seq-and-reserved = hexOctet:\n    // clock-seq-low          = hexOctet\n    // node                   = 6hexOctet\n    // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\n    // y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10\n    // y values are 8, 9, A, B\n    let buffer = new Uint8Array(16)\n    crypto.getRandomValues(buffer)\n    //buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).\n    buffer[6] |= 0x40 //buffer[6] | 01000000 will set the 6 bit to 1.\n    buffer[6] &= 0x4f //buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = \"4\".\n    //buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.\n    buffer[8] |= 0x80 //buffer[8] | 10000000 will set the 7 bit to 1.\n    buffer[8] &= 0xbf //buffer[8] & 10111111 will set the 6 bit to 0.\n    buffer = buffer.map((n) => {\n        let hex = n.toString(16)\n        while (hex.length < 2) {\n            hex = \"0\" + hex\n        }\n        return hex as any\n    })\n\n    return (\n        buffer[0] +\n        buffer[1] +\n        buffer[2] +\n        buffer[3] +\n        \"-\" +\n        buffer[4] +\n        buffer[5] +\n        \"-\" +\n        buffer[6] +\n        buffer[7] +\n        \"-\" +\n        buffer[8] +\n        buffer[9] +\n        \"-\" +\n        buffer[10] +\n        buffer[11] +\n        buffer[12] +\n        buffer[13] +\n        buffer[14] +\n        buffer[15]\n    )\n}\n\n// let haveSameHost = (a: string, b: string) => new URL(a).host === new URL(b).host\n\nlet getItem = (key: string) => Storage.getItem(key)\n\nlet isEmpty = (str: string) => !str || !str.length\n\nlet has = (obj: any, key: string) => Object.hasOwnProperty.call(obj, key)\n\nlet now = () => Math.round(Date.now() / 1000)\n\nenum StorageKey {\n    TOKEN_KEYS = \"adal.token.keys\",\n    ACCESS_TOKEN_KEY = \"adal.access.token.key\",\n    EXPIRATION_KEY = \"adal.expiration.key\",\n    STATE_LOGIN = \"adal.state.login\",\n    STATE_RENEW = \"adal.state.renew\",\n    NONCE_IDTOKEN = \"adal.nonce.idtoken\",\n    SESSION_STATE = \"adal.session.state\",\n    USERNAME = \"adal.username\",\n    IDTOKEN = \"adal.idtoken\",\n    ERROR = \"adal.error\",\n    ERROR_DESCRIPTION = \"adal.error.description\",\n    LOGIN_REQUEST = \"adal.login.request\",\n    LOGIN_ERROR = \"adal.login.error\",\n    RENEW_STATUS = \"adal.token.renew.status\",\n}\n\ninterface IStorage {\n    getItem(key: string): any\n    setItem(key: string, value: any, preserve?: boolean): void\n}\n\nconst Storage: IStorage = (() => {\n    function supportsStorage(type: string) {\n        const storage = window[type]\n        if (!storage) {\n            return false\n        }\n        const testKey = \"__test__\"\n        storage.setItem(testKey, testKey)\n        if (storage.getItem(testKey) !== testKey) {\n            return false\n        }\n        storage.removeItem(testKey)\n        if (storage.getItem(testKey)) {\n            return false\n        }\n        return true\n    }\n\n    if (supportsStorage(\"localStorage\")) return localStorage\n    if (supportsStorage(\"sessionStorage\")) return sessionStorage\n    return {getItem() {}, setItem() {}} as IStorage\n})()\n\nexport enum LogLevel {\n    Error = 0,\n    Warn,\n    Info,\n    Verbose,\n}\n\nconst LOG_LEVEL_LABELS = {\n    [LogLevel.Error]: \"ERROR\",\n    [LogLevel.Warn]: \"WARNING\",\n    [LogLevel.Info]: \"INFO\",\n    [LogLevel.Verbose]: \"VERBOSE\",\n}\n\nconst Logger = {\n    pii: false,\n    correlationId: undefined,\n    level: LogLevel.Error,\n\n    /**\n     * Checks the Logging Level, constructs the Log message and logs it. Users need to implement/override this method to turn on Logging.\n     * @param {number} level  -  Level can be set 0,1,2 and 3 which turns on 'error', 'warning', 'info' or 'verbose' level logging respectively.\n     * @param {string} message  -  Message to log.\n     * @param {string} error  -  Error to log.\n     */\n    log(\n        level: LogLevel,\n        message: string,\n        error: Error | string | undefined | null,\n        containsPii = false,\n    ) {\n        if (containsPii && !this.pii) return\n\n        if (level <= this.level) {\n            let timestamp = new Date().toUTCString()\n            let formattedMessage =\n                timestamp +\n                \":\" +\n                (this.correlationId ? this.correlationId + \"-\" : \"\") +\n                LOG_LEVEL_LABELS[level] +\n                \": \" +\n                message\n\n            if (error) {\n                // @ts-expect-error\n                formattedMessage += \"\\nstack:\\n\" + error.stack\n            }\n\n            console.log(formattedMessage)\n        }\n    },\n\n    /**\n     * Logs messages when Logging Level is set to 0.\n     * @param {string} message  -  Message to log.\n     * @param {string} error  -  Error to log.\n     */\n    error(message: string, error?: Error) {\n        this.log(LogLevel.Error, message, error)\n    },\n\n    /**\n     * Logs messages when Logging Level is set to 1.\n     * @param {string} message  -  Message to log.\n     */\n    warn(message: string) {\n        this.log(LogLevel.Warn, message, null)\n    },\n\n    /**\n     * Logs messages when Logging Level is set to 2.\n     * @param {string} message  -  Message to log.\n     */\n    info(message: string) {\n        this.log(LogLevel.Info, message, null)\n    },\n\n    /**\n     * Logs messages when Logging Level is set to 3.\n     * @param {string} message  -  Message to log.\n     */\n    verbose(message: string) {\n        this.log(LogLevel.Verbose, message, null)\n    },\n\n    /**\n     * Logs Pii messages when Logging Level is set to 0 and window.piiLoggingEnabled is set to true.\n     * @param {string} message  -  Message to log.\n     * @param {string} error  -  Error to log.\n     */\n    errorPii(message: string, error: string) {\n        this.log(LogLevel.Error, message, error, true)\n    },\n\n    /**\n     * Logs  Pii messages when Logging Level is set to 1 and window.piiLoggingEnabled is set to true.\n     * @param {string} message  -  Message to log.\n     */\n    warnPii(message: string) {\n        this.log(LogLevel.Warn, message, null, true)\n    },\n\n    /**\n     * Logs messages when Logging Level is set to 2 and window.piiLoggingEnabled is set to true.\n     * @param {string} message  -  Message to log.\n     */\n    infoPii(message: string) {\n        this.log(LogLevel.Info, message, null, true)\n    },\n\n    /**\n     * Logs messages when Logging Level is set to 3 and window.piiLoggingEnabled is set to true.\n     * @param {string} message  -  Message to log.\n     */\n    verbosePii(message: string) {\n        this.log(LogLevel.Verbose, message, null, true)\n    },\n}\n"],"names":["RequestType","ResponseType","TokenRenewStatus","AuthenticationContext","config","window","_user","_idTokenNonce","readConfig","_activeRenewals","_loginInProgress","_acquireTokenInProgress","_renewStates","_openedWindows","_callBackMappedToRenewStates","_callBacksMappedToRenewStates","_requestType","LOGIN","handlePopupError","loginCallback","resource","error","errorDesc","loginError","saveItem","StorageKey","ERROR","ERROR_DESCRIPTION","LOGIN_ERROR","loginPopup","urlNavigate","callback","popupWindow","title","popUpWidth","popUpHeight","left","innerWidth","screenX","top","innerHeight","screenY","open","focus","e","openPopup","push","registeredRedirectUri","redirectUri","split","pollTimer","setInterval","closed","undefined","clearInterval","popUpWindowLocation","location","encodeURI","href","indexOf","handleWindowCallback","hash","close","registerCallback","expectedState","token","tokenType","i","length","renewToken","responseType","frameHandle","addAdalFrame","guid","state","removeQueryStringParameter","getNavigateUrl","ID_TOKEN","NONCE_IDTOKEN","encode","addHintParameters","src","loadFrameTimeout","renewIdToken","clientId","urlNavigation","frameName","RENEW_STATUS","InProgress","loadFrame","setTimeout","getItem","Canceled","promptUser","url","replace","profile","sid","urlContainsQueryStringParameter","upn","parts","createUser","idToken","json","encodedIdToken","decodedToken","decodeJWT","base64IdToken","base64Decoded","JWSPayload","decodeURIComponent","escape","atob","JSON","parse","err","extractIdToken","has","aud","toLowerCase","userName","email","isCallback","self","isPopup","lastWindow","opener","_AuthenticationContextInstance","_adalInstance","parent","tokenReceivedCallback","requestInfo","getRequestInfo","stateResponse","saveTokenFromHash","requestType","RENEW_TOKEN","parameters","navigateToLoginRequestUrl","LOGIN_REQUEST","instance","tenant","serialize","iframeId","document","getElementById","body","insertAdjacentHTML","frames","login","loginStartPage","STATE_LOGIN","displayCall","popUp","logout","SESSION_STATE","STATE_RENEW","IDTOKEN","keys","TOKEN_KEYS","isEmpty","ACCESS_TOKEN_KEY","EXPIRATION_KEY","clearCache","logOutUri","postLogoutRedirectUri","getUser","acquireToken","hasResource","expiry","now","expireOffsetSeconds","getCachedToken","extraQueryParameter","acquireTokenPopup","extraQueryParameters","claims","canAcquireToken","Error","valid","stateMatch","UNKNOWN","deserialize","getHash","loginStates","acquireTokenStates","matchState","getResourceFromState","error_description","expiresIn","matchNonce","loginResource","exp","nonce","description","Completed","loginInProgress","clearCacheForResource","jwt","matches","exec","header","JWSSig","laodFrameTimeout","str","encodeURIComponent","name","RegExp","test","key","value","preserve","old","Storage","setItem","substring","query","pl","search","decode","s","obj","match","user","requestNonce","splitIndex","expires","parseInt","slice","correlationId","join","buffer","Uint8Array","crypto","getRandomValues","map","n","hex","toString","Object","hasOwnProperty","call","Math","round","Date","supportsStorage","type","storage","testKey","removeItem","localStorage","sessionStorage","LogLevel"],"mappings":"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"}